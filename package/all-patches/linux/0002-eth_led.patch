diff --git a/drivers/net/ethernet/ingenic/Kconfig b/drivers/net/ethernet/ingenic/Kconfig
index 0b6ce74b8..362a2d676 100644
--- a/drivers/net/ethernet/ingenic/Kconfig
+++ b/drivers/net/ethernet/ingenic/Kconfig
@@ -22,6 +22,24 @@ config JZ_MAC_V13
 	  Select for X1000
 endchoice
 
+config JZ_INTERNAL_MAC_PHY
+	depends on SOC_T21 && JZ_MAC
+	bool "internal phy"
+	help
+		Select for t21
+
+config JZ_INTERNAL_MAC_PHY_LED_SOFTWARE_CTRL
+	depends on JZ_INTERNAL_MAC_PHY
+	bool "internal phy led controled by software instead of phy hardware"
+	help
+		Select for t21
+
+config JZ_MAC_SPEED_LED_SOFTWARE_CTRL
+	depends on JZ_INTERNAL_MAC_PHY_LED_SOFTWARE_CTRL
+	bool "internal phy speed led controled by software instead of phy hardware"
+	help
+		Select for t21
+
 config JZ_MAC_MODE
 	tristate "ingenic on-chip MAC support mode"
 	depends on JZ_MAC
diff --git a/drivers/net/ethernet/ingenic/jz_mac_v13.c b/drivers/net/ethernet/ingenic/jz_mac_v13.c
index 1bf328ac7..1cf3197a8 100644
--- a/drivers/net/ethernet/ingenic/jz_mac_v13.c
+++ b/drivers/net/ethernet/ingenic/jz_mac_v13.c
@@ -152,6 +152,84 @@ static int jzmac_phy_reset(void)
 }
 #endif
 
+static int jzmac_cpm_phy_reset()
+{
+	unsigned int mphyc = cpm_inl(CPM_MPHYC);
+	//printk("%s(%d):mphyc=%x\n", __func__, __LINE__, mphyc);
+	mphyc |= (1 << 3);
+	cpm_outl(mphyc, CPM_MPHYC);
+	msleep(50);
+	mphyc &= ~(1 << 3);
+	cpm_outl(mphyc, CPM_MPHYC);
+	msleep(50);
+	//printk("%s(%d):mphyc=%x\n", __func__, __LINE__, cpm_inl(CPM_MPHYC));
+
+	return 0;
+}
+
+#ifdef CONFIG_JZ_INTERNAL_MAC_PHY_LED_SOFTWARE_CTRL
+#define GMAC_INNER_PHY_LINKACT_LED_GPIO (32+15)
+#define GMAC_INNER_PHY_LINKACT_LED_ACTIVE_LEVEL (1)
+static int gmac_inner_phy_linkact_gpio_status = 0;
+static int gmac_inner_phy_linkact_gpio_requested = 0;
+
+static int gamc_inner_phy_led_ctrl_link(int link)
+{
+	int rc = 0;
+	if (0 == gmac_inner_phy_linkact_gpio_requested) {
+		rc = gpio_request(GMAC_INNER_PHY_LINKACT_LED_GPIO, "jzmac");
+		if (rc < 0) {
+			printk("failed to request GPIO %d\n",
+					GMAC_INNER_PHY_LINKACT_LED_GPIO);
+		}
+		gmac_inner_phy_linkact_gpio_requested = 1;
+	}
+	if (link) {
+		gmac_inner_phy_linkact_gpio_status = GMAC_INNER_PHY_LINKACT_LED_ACTIVE_LEVEL;
+		gpio_direction_output(GMAC_INNER_PHY_LINKACT_LED_GPIO, gmac_inner_phy_linkact_gpio_status);
+	} else {
+		gmac_inner_phy_linkact_gpio_status = !GMAC_INNER_PHY_LINKACT_LED_ACTIVE_LEVEL;
+		gpio_direction_output(GMAC_INNER_PHY_LINKACT_LED_GPIO, gmac_inner_phy_linkact_gpio_status);
+	}
+	return 0;
+}
+static int gamc_inner_phy_led_ctrl_act(void)
+{
+	int rc = 0;
+	if (0 == gmac_inner_phy_linkact_gpio_requested) {
+		rc = gpio_request(GMAC_INNER_PHY_LINKACT_LED_GPIO, "jzmac");
+		if (rc < 0) {
+			printk("failed to request GPIO %d\n",
+					GMAC_INNER_PHY_LINKACT_LED_GPIO);
+		}
+		gmac_inner_phy_linkact_gpio_requested = 1;
+	}
+	gmac_inner_phy_linkact_gpio_status = !gmac_inner_phy_linkact_gpio_status;
+	gpio_direction_output(GMAC_INNER_PHY_LINKACT_LED_GPIO, gmac_inner_phy_linkact_gpio_status);
+	return 0;
+}
+
+#ifdef CONFIG_JZ_MAC_SPEED_LED_SOFTWARE_CTRL
+#define GMAC_INNER_PHY_SPEED_LED_GPIO (32+6)
+static int gmac_inner_phy_speed_gpio_requested = 0;
+static int gmac_inner_phy_speed_led_ctrl(unsigned int value)
+{
+	int rc = 0;
+	if (0 == gmac_inner_phy_speed_gpio_requested) {
+		rc = gpio_request(GMAC_INNER_PHY_SPEED_LED_GPIO, "jzmac");
+		if (rc < 0) {
+			printk("failed to request GPIO %d\n",
+					GMAC_INNER_PHY_SPEED_LED_GPIO);
+		}
+		gmac_inner_phy_speed_gpio_requested = 1;
+	}
+	gpio_direction_output(GMAC_INNER_PHY_SPEED_LED_GPIO, value);
+	return 0;
+}
+#endif
+
+#endif
+
 static inline unsigned char str2hexnum(unsigned char c)
 {
 	if (c >= '0' && c <= '9')
@@ -808,9 +886,15 @@ static void jz_mac_adjust_link(struct net_device *dev)
 					break;
 				case 100:
 					synopGMAC_select_speed100(gmacdev);
+#ifdef CONFIG_JZ_MAC_SPEED_LED_SOFTWARE_CTRL
+					gmac_inner_phy_speed_led_ctrl(1);
+#endif
 					break;
 				case 10:
 					synopGMAC_select_speed10(gmacdev);
+#ifdef CONFIG_JZ_MAC_SPEED_LED_SOFTWARE_CTRL
+					gmac_inner_phy_speed_led_ctrl(0);
+#endif
 					break;
 				default:
 					printk(KERN_ERR "GMAC PHY speed NOT match!\n");
@@ -828,6 +912,9 @@ static void jz_mac_adjust_link(struct net_device *dev)
 			//mod_timer(&lp->watchdog_timer, jiffies + 1);
 		}
 	} else if (lp->old_link) {
+#ifdef CONFIG_JZ_MAC_SPEED_LED_SOFTWARE_CTRL
+		gmac_inner_phy_speed_led_ctrl(0);
+#endif
 		new_state = 1;
 		lp->old_link = 0;
 		lp->old_speed = 0;
@@ -875,10 +962,10 @@ static int mii_probe(struct net_device *dev)
 			 PHY_INTERFACE_MODE_RMII);
 #elif defined(CONFIG_JZ_MAC_RGMII)
 	phydev = phy_connect(dev, dev_name(&phydev->dev), &jz_mac_adjust_link,
-			 PHY_INTERFACE_MODE_RGMII);
+			0, PHY_INTERFACE_MODE_RGMII);
 #elif defined(CONFIG_JZ_MAC_GMII)
 	phydev = phy_connect(dev, dev_name(&phydev->dev), &jz_mac_adjust_link,
-			 PHY_INTERFACE_MODE_GMII);
+			0, PHY_INTERFACE_MODE_GMII);
 #else
 	phydev = phy_connect(dev, dev_name(&phydev->dev), &jz_mac_adjust_link,
 			 PHY_INTERFACE_MODE_MII);
@@ -1228,12 +1315,18 @@ static int jz_mac_hard_start_xmit(struct sk_buff *skb,
 		tx_ring->next_to_use = first;
 	}
 
+#ifdef CONFIG_JZ_INTERNAL_MAC_PHY_LED_SOFTWARE_CTRL
+	gamc_inner_phy_led_ctrl_act();
+#endif
+
 	//jzmac_dump_all_regs(__func__, __LINE__);
 	//jzmac_dump_all_desc(lp);
 
 	return NETDEV_TX_OK;
 }
 
+unsigned int g_tx_packets = 0;
+
 static bool jzmac_clean_tx_irq(struct jz_mac_local *lp) {
 	struct net_device *netdev = lp->netdev;
 	DmaDesc *desc;
@@ -1289,10 +1382,13 @@ static bool jzmac_clean_tx_irq(struct jz_mac_local *lp) {
 	lp->total_tx_packets += total_tx_packets;
 	lp->net_stats.tx_bytes += total_tx_bytes;
 	lp->net_stats.tx_packets += total_tx_packets;
+	g_tx_packets = lp->net_stats.tx_packets;
 
 	return (count < tx_ring->count);
 }
 
+unsigned int g_rx_packets = 0;
+
 static bool jzmac_clean_rx_irq(struct jz_mac_local *lp,
 		int *work_done, int work_to_do) {
 
@@ -1420,6 +1516,7 @@ invalid_pkt:
 	lp->net_stats.rx_bytes += total_rx_bytes;
 	lp->net_stats.rx_packets += total_rx_packets;
 
+        g_rx_packets = lp->net_stats.rx_packets;
 	return cleaned;
 }
 
@@ -1829,8 +1926,10 @@ static int jz_mac_open(struct net_device *dev)
 		return -EINVAL;
 	}
 
+#ifndef CONFIG_JZ_INTERNAL_MAC_PHY
 	phy_write(lp->phydev, MII_BMCR, BMCR_RESET);
 	while(phy_read(lp->phydev, MII_BMCR) & BMCR_RESET);
+#endif
 	phy_start(lp->phydev);
 
 	if (synopGMAC_reset(gmacdev) < 0) {
@@ -1879,15 +1978,13 @@ static int jz_mac_open(struct net_device *dev)
 static int jz_mac_close(struct net_device *dev)
 {
 	struct jz_mac_local *lp = netdev_priv(dev);
-    	int data = 0;
 
 	jz_mac_disable(lp);
 
 	netif_carrier_off(dev);
 
 	phy_stop(lp->phydev);
-	data = phy_read(lp->phydev, MII_BMCR);
-	phy_write(lp->phydev, MII_BMCR, (data | BMCR_PDOWN));
+	phy_write(lp->phydev, MII_BMCR, BMCR_PDOWN);
 
 	/* free the rx/tx buffers */
 	desc_list_free(lp);
@@ -2121,6 +2218,24 @@ static int jz_mac_probe(struct platform_device *pdev)
 	//	jzmac_dump_all_regs(__func__, __LINE__);
 	//synopGMAC_multicast_enable(gmacdev);
 
+#ifdef CONFIG_JZ_INTERNAL_MAC_PHY_LED_SOFTWARE_CTRL
+	rc = gpio_request(GMAC_INNER_PHY_LINKACT_LED_GPIO, "jzmac");
+	if (rc < 0) {
+		printk("failed to request GPIO %d\n",
+		       GMAC_INNER_PHY_LINKACT_LED_GPIO);
+	}
+#ifdef CONFIG_JZ_MAC_SPEED_LED_SOFTWARE_CTRL
+	if (0 == gmac_inner_phy_speed_gpio_requested) {
+		rc = gpio_request(GMAC_INNER_PHY_SPEED_LED_GPIO, "jzmac");
+		if (rc < 0) {
+			printk("failed to request GPIO %d\n",
+					GMAC_INNER_PHY_SPEED_LED_GPIO);
+		}
+		gmac_inner_phy_speed_gpio_requested = 1;
+	}
+#endif
+#endif
+
 	/* proc info */
 	proc = jz_proc_mkdir("mdio");
 	if (!proc) {
@@ -2217,6 +2332,11 @@ static int jz_mdiobus_read(struct mii_bus *bus, int phy_addr, int regnum)
 		printk("err(%s): ret = %d\n", __func__, ret);
 	}
 	status = synopGMAC_read_phy_reg(gmacdev, phy_addr, regnum, &data);
+#ifdef CONFIG_JZ_INTERNAL_MAC_PHY_LED_SOFTWARE_CTRL
+	if (1 == regnum) {
+		gamc_inner_phy_led_ctrl_link(0x4&data);
+	}
+#endif
 	up(&mutex_mdio);
 	//printk("=======>mdio read phy%d reg %d, return data = 0x%04x status = %d\n",
 	//		phy_addr, regnum, data, status);
@@ -2281,7 +2401,12 @@ static int  jz_mii_bus_probe(struct platform_device *pdev)
 		clk_put(clk_gate);
 		goto out_err_alloc;
 	}
+
+#ifdef CONFIG_JZ_INTERNAL_MAC_PHY
+	clk_set_rate(clk_cgu, 25000000);
+#else
 	clk_set_rate(clk_cgu, 50000000);
+#endif
 
 	/* //	synopGMAC_multicast_enable(gmacdev); */
 
@@ -2294,6 +2419,10 @@ static int  jz_mii_bus_probe(struct platform_device *pdev)
 	}
 #endif
 
+	if (jzmac_cpm_phy_reset() < 0) {
+		goto out_err_alloc;
+	}
+
 #if defined(CONFIG_JZ_MAC_RGMII) || defined(CONFIG_JZ_MAC_GMII)
 	/* CIM0_MCLK/GMAC_GTXC/EPD_PWC/PB9 */
 	jzgpio_set_func(GPIO_PORT_B, GPIO_FUNC_0, 0x00000200);
